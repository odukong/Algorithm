# [ Lv.2 ] 12914. 멀리 뛰기

<img src="https://img.shields.io/badge/JavaScript-orange?style=flat&logo=javascript&logoColor=auto"/> [문제 바로가기](https://school.programmers.co.kr/learn/courses/30/lessons/12914)

### 풀이 날짜

- 2024.04.15

### 성능

- 최소
  - 속도 : 0.04ms
  - 용량 : 33.5MB
- 최대
  - 속도 : 0.33ms
  - 용량 : 33.5MB

### 문제 구분

- 연습 문제

### 문제

효진이는 멀리 뛰기를 연습하고 있습니다. 효진이는 한번에 1칸, 또는 2칸을 뛸 수 있습니다. 칸이 총 4개 있을 때, 효진이는
(1칸, 1칸, 1칸, 1칸)
(1칸, 2칸, 1칸)
(1칸, 1칸, 2칸)
(2칸, 1칸, 1칸)
(2칸, 2칸)
의 5가지 방법으로 맨 끝 칸에 도달할 수 있습니다. 멀리뛰기에 사용될 칸의 수 n이 주어질 때, 효진이가 끝에 도달하는 방법이 몇 가지인지 알아내, 여기에 1234567를 나눈 나머지를 리턴하는 함수, solution을 완성하세요. 예를 들어 4가 입력된다면, 5를 return하면 됩니다.

### 제한사항

- n은 1 이상, 2000 이하인 정수입니다.

### 입출력 예

| n   | result |
| --- | ------ |
| 4   | 5      |
| 3   | 3      |

### 풀이 설명

❌ n칸을 뛰는 방법의 수를 순서를 생각하지 않고 구하면, `Math.floor(n+1/2) ~ 1 or 0` 범위와 같다. 멀리뛰기 시 각 방법에서 사용될 1칸을 뛰는 횟수를 이용해 반복문을 수행하고, (1칸,2칸,1칸)을 뛰어야 한다면 1칸을 뛰는 횟수는 총 2번이므로 **같은 것이 있는 순열**을 이용해 fact함수를 생성하였다. 하지만 fact 함수에서 정수 범위를 넘어가며 값이 overflow가 되면서 중간에 값이 이상해지는 문제가 발생한다. 이를 방지하기 위해 모든 단계마다 %123456789를 한다면 이 역시도 원하는 값이 나올 수 없기 때문에 해당 문제는 `factorial`을 이용해 풀 수 없다고 생각하여 **Dynamic Programming**방식으로 구현하는 것을 목표로 하였다.
✅ 문제를 잘 살펴보면, <u>1칸을 갈 때의 방법의 개수는 1개, 2칸은 2개, 3칸은 3개, 4칸 5개, 5칸 8개</u>로 피보나치 수열이라는 규칙을 확인할 수 있다. 피보나치와 dp를 이용하여, n칸을 이동하는 경우의 수를 구하여 최종적으로 dp[n]을 return 하면 된다.
