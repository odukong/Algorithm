# [ Lv.2 ] 135807. 숫자 카드 나누기

<img src="https://img.shields.io/badge/JavaScript-orange?style=flat&logo=javascript&logoColor=auto"/> [문제 바로가기](https://school.programmers.co.kr/learn/courses/30/lessons/135807)

### 풀이 날짜

- 2025.12.05

### 문제 구분

- 최대공약수(GCD)

### 문제

철수와 영희는 선생님으로부터 숫자가 하나씩 적힌 카드들을 절반씩 나눠서 가진 후, 다음 두 조건 중 하나를 만족하는 가장 큰 양의 정수 a의 값을 구하려고 합니다.

철수가 가진 카드들에 적힌 모든 숫자를 나눌 수 있고 영희가 가진 카드들에 적힌 모든 숫자들 중 하나도 나눌 수 없는 양의 정수 a
영희가 가진 카드들에 적힌 모든 숫자를 나눌 수 있고, 철수가 가진 카드들에 적힌 모든 숫자들 중 하나도 나눌 수 없는 양의 정수 a
예를 들어, 카드들에 10, 5, 20, 17이 적혀 있는 경우에 대해 생각해 봅시다. 만약, 철수가 [10, 17]이 적힌 카드를 갖고, 영희가 [5, 20]이 적힌 카드를 갖는다면 두 조건 중 하나를 만족하는 양의 정수 a는 존재하지 않습니다. 하지만, 철수가 [10, 20]이 적힌 카드를 갖고, 영희가 [5, 17]이 적힌 카드를 갖는다면, 철수가 가진 카드들의 숫자는 모두 10으로 나눌 수 있고, 영희가 가진 카드들의 숫자는 모두 10으로 나눌 수 없습니다. 따라서 철수와 영희는 각각 [10, 20]이 적힌 카드, [5, 17]이 적힌 카드로 나눠 가졌다면 조건에 해당하는 양의 정수 a는 10이 됩니다.

철수가 가진 카드에 적힌 숫자들을 나타내는 정수 배열 arrayA와 영희가 가진 카드에 적힌 숫자들을 나타내는 정수 배열 arrayB가 주어졌을 때, 주어진 조건을 만족하는 가장 큰 양의 정수 a를 return하도록 solution 함수를 완성해 주세요. 만약, 조건을 만족하는 a가 없다면, 0을 return 해 주세요.

### 제한사항

- 1 ≤ arrayA의 길이 = arrayB의 길이 ≤ 500,000
- 1 ≤ arrayA의 원소, arrayB의 원소 ≤ 100,000,000
- arrayA와 arrayB에는 중복된 원소가 있을 수 있습니다.

### 입출력 예

| arrayA        | arrayB        | result |
| ------------- | ------------- | ------ |
| [10, 17]      | [5, 20]       | 0      |
| [10, 20]      | [5, 17]       | 10     |
| [14, 35, 119] | [18, 30, 102] | 7      |

### 입출력 예 설명

입출력 예 #1

문제 예시와 같습니다.
입출력 예 #2

문제 예시와 같습니다.
입출력 예 #3

철수가 가진 카드에 적힌 숫자들은 모두 3으로 나눌 수 없고, 영희가 가진 카드에 적힌 숫자는 모두 3으로 나눌 수 있습니다. 따라서 3은 조건에 해당하는 양의 정수입니다. 하지만, 철수가 가진 카드들에 적힌 숫자들은 모두 7로 나눌 수 있고, 영희가 가진 카드들에 적힌 숫자는 모두 7로 나눌 수 없습니다. 따라서 최대값인 7을 return 합니다.

### 풀이 설명

✅ `arrayA`, `arrayB` 각 배열에서 **가장 작은 요소**의 약수가 결국엔 각 배열의 요소를 모두 나눌 수 있는 후보가 된다는 점을 활용하였습니다. 각 배열이 정렬되어 주어진다는 점을 활용하여 가장 작은 요소를 `arrayA[0]`, `arrayB[0]` 배열 맨 앞에 위치하는 값으로 정의하였습니다.

1. `A`, `B`의 공약수를 모두 구합니다. 계산 효율을 위해 각 배열의 가장 작은 요소의 약수를 기준으로 해서 계산합니다. 이때 **가장 작은 요소의 약수**를 기준으로 하되, `A` or `B`의 요소들이 모두 나눠지는 값만을 포함하도록 합니다. (`getDivisors`)
   - `getDivisors`는 약수를 구할 때, **1부터 가장 작은 요소의 제곱근**까지로 범위를 설정합니다. 100을 5로 나눈다 하였을 때, 5를 약수에 넣고, 100/5=20 즉, 20도 약수로 바로 계산할 수 있으니 한 번에 `divider`, `pair`(`num/divider`) 두 가지 약수를 구합니다.
2. 구한 공약수들을 기준으로 `A`의 공약수들 중에 `B` 배열의 요소를 나누지는 않는 가장 큰 값(`A_MAX`)을 반환하도록 합니다. (B의 경우도 마찬가지입니다). 이 때 중요한 것은 각 요소의 큰 공약수부터 내림차순으로 계산하는 것입니다.
3. 결과적으로 `A`,`B` 자신의 요소들은 모두 나누어지되, 상대의 요소는 나눌 수 없는 가장 큰 약수를 `A`,`B`를 비교하여 둘 중에 더 큰 값을 결과값으로 반환하도록 합니다.
