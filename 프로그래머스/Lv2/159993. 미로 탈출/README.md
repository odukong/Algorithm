# [ Lv.2 ] 159993. 미로 탈출

<img src="https://img.shields.io/badge/JavaScript-orange?style=flat&logo=javascript&logoColor=auto"/> [문제 바로가기](https://school.programmers.co.kr/learn/courses/30/lessons/159993)

### 풀이 날짜

- 2025.12.04

### 문제 구분

- BFS

### 문제

1 x 1 크기의 칸들로 이루어진 직사각형 격자 형태의 미로에서 탈출하려고 합니다. 각 칸은 통로 또는 벽으로 구성되어 있으며, 벽으로 된 칸은 지나갈 수 없고 통로로 된 칸으로만 이동할 수 있습니다. 통로들 중 한 칸에는 미로를 빠져나가는 문이 있는데, 이 문은 레버를 당겨서만 열 수 있습니다. 레버 또한 통로들 중 한 칸에 있습니다. 따라서, 출발 지점에서 먼저 레버가 있는 칸으로 이동하여 레버를 당긴 후 미로를 빠져나가는 문이 있는 칸으로 이동하면 됩니다. 이때 아직 레버를 당기지 않았더라도 출구가 있는 칸을 지나갈 수 있습니다. 미로에서 한 칸을 이동하는데 1초가 걸린다고 할 때, 최대한 빠르게 미로를 빠져나가는데 걸리는 시간을 구하려 합니다.

미로를 나타낸 문자열 배열 maps가 매개변수로 주어질 때, 미로를 탈출하는데 필요한 최소 시간을 return 하는 solution 함수를 완성해주세요. 만약, 탈출할 수 없다면 -1을 return 해주세요.

### 제한사항

- 5 ≤ maps의 길이 ≤ 100
  - 5 ≤ maps[i]의 길이 ≤ 100
  - maps[i]는 다음 5개의 문자들로만 이루어져 있습니다.
    - S : 시작 지점
    - E : 출구
    - L : 레버
    - O : 통로
    - X : 벽
  - 시작 지점과 출구, 레버는 항상 다른 곳에 존재하며 한 개씩만 존재합니다.
  - 출구는 레버가 당겨지지 않아도 지나갈 수 있으며, 모든 통로, 출구, 레버, 시작점은 여러 번 지나갈 수 있습니다.

### 입출력 예

| maps                                      | result |
| ----------------------------------------- | ------ |
| ["SOOOL","XXXXO","OOOOO","OXXXX","OOOOE"] | 16     |
| ["LOOXS","OOOOX","OOOOO","OOOOO","EOOOO"] | -1     |

### 입출력 예 설명

입출력 예 #1

주어진 문자열은 다음과 같은 미로이며
![example1](https://user-images.githubusercontent.com/62426665/214443486-cb2b84a4-afc6-4b25-8da2-645a853859f1.png)

다음과 같이 이동하면 가장 빠른 시간에 탈출할 수 있습니다.

![example2](https://user-images.githubusercontent.com/62426665/207090680-93289071-da4f-4126-9c31-066c1d4d3802.png)

4번 이동하여 레버를 당기고 출구까지 이동하면 총 16초의 시간이 걸립니다. 따라서 16을 반환합니다.

입출력 예 #2

주어진 문자열은 다음과 같은 미로입니다.

![image3](https://user-images.githubusercontent.com/62426665/214443892-1e7734e9-b4c8-49af-ba29-aa5597039617.png)

시작 지점에서 이동할 수 있는 공간이 없어서 탈출할 수 없습니다. 따라서 -1을 반환합니다.

### 풀이 설명

✅ 출발지부터 목적지까지의 **최단거리**(이동시간이 칸마다 1초로 동일하기 때문에 같은 의미로 취급함)를 상하좌우로 이동하며 구하는 문제이기 때문에 `BFS`를 활용하여 풀이를 진행했습니다.

1. 시작지점, 목적지에 따라 최단 거리를 구하는 BFS함수를 구현
   - 이때 시작지점은 시작점(**S**)과 레버 위치(**L**)로 구분될 수 있습니다. `findWord`함수를 정의하여 특정 지점을 [x,y] 좌표로 반환할 수 있도록 하였습니다.
2. (S➡️L) 시작점에서 레버 위치까지 걸리는 최소 시간을 구합니다.(처음 시도에서는 레버를 무조건 지나쳐야하는 점을 고려하지 않고 구현하여 에러가 발생했습니다.) 시작점을 기준으로 상하좌우 좌표를 탐색하도록 queue에 좌표 값과 소요된 시간(time)을 push하여 queue에 탐색할 좌표 값이 없을 때까지 반복하거나 좌표 값이 목적지 값과 일치하다면, 소요된 (최소)시간을 반환합니다.
   - 단, 좌표값을 queue에 넣을 때 경계값을 넘거나, 벽(**X**) 좌표이거나 이미 방문한 좌표라면 queue에 넣지 않습니다. (최소 시간을 구해야 함)
3. (L➡️E) 레버 위치에서 출구까지의 소요 시간을 이전에 진행한 BFS과정과 동일한 로직을 통해 도출합니다. 이때 시작점(**S**)에서 레버 위치(**L**)까지 걸린 시간에서 소요 시간을 이어서 계산합니다.
